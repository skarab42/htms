# HTMS 💨 Streaming HTML Without The Headaches

> **"What if async content was actually SEO-friendly?"**
>
> *(HTML streaming: ancient wisdom, modern awakening, progressive enhancement™.)*


HTMS solves the classic web development dilemma: you want instant page loads AND progressive content updates, but every
solution forces you to choose between SEO-friendly server rendering or complex client-side applications.

**HTMS gives you both.** Stream HTML progressively with perfect SEO, lightning-fast first paint, and just a few lines of
JavaScript that clean up their own mess once the stream finishes.

[![Rust](https://img.shields.io/badge/rust-000000.svg?&style=for-the-badge&logo=rust&logoColor=white)](https://www.rust-lang.org/)
[![HTML5](https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white)](https://developer.mozilla.org/en-US/docs/Web/HTML)
[![Streaming](https://img.shields.io/badge/streaming-💨-blue?style=for-the-badge)](https://github.com/skarab42/htms)
[![License](https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge)](license.md)

---

## ⚡ The 30-Second Demo

HTMS is primarily about **streaming HTML**. The core idea? Bind HTML `data-htms` attributes to auto-generated async
methods that progressively replace content. Here's how it looks:

Write normal HTML with `data-htms` attributes:

```html
<header>Static content loads instantly</header>
<div data-htms="fn:breaking_news">Loading news...</div>
<div data-htms="fn:user_dashboard">Loading dashboard...</div>
<footer>Static content loads instantly</footer>
```

Write normal Rust async functions:

```rust
use htms::Template;

#[derive(Template)]
#[template = "page.html"]
pub struct HomePage;

// The `HomePageRender` trait is auto generated by the derive macro
impl HomePageRender for HomePage {
    async fn breaking_news_task() -> String {
        // Some API call - takes 2 seconds
        fetch_latest_news().await
    }

    async fn user_dashboard_task() -> String {
        // Heavy computation - takes 5 seconds
        generate_user_analytics().await
    }
}
```

Stream it all in one request with your favorite backend, here with [Axum](https://github.com/tokio-rs/axum) and our
adapter:

```rust
use htms::axum::HtmlStream;

async fn home_page_handler() -> Response {
    let stream = HomePage::default().render().map(Ok::<Bytes, Infallible>);

    HtmlStream::from(stream).into_response()
}
```

**Result:** Your page appears instantly with static content, then sections fill in progressively as async tasks
complete. All content is SEO-visible in the initial HTTP response.

```bash
cargo run -p demo --example axum
# Visit http://localhost:3000 and watch the magic
```

## 🧠 How It Actually Works

The secret is **streaming everything in one HTTP request**:

1. **Instant delivery**: Static HTML streams immediately to the browser
2. **Progressive enhancement**: Async content arrives as tags in the same stream
3. **Seamless replacement**: four lines of JavaScript swap placeholders with real content
4. **Perfect SEO**: All content (even async parts) is in the HTML source

``` javascript
// This is literally all the JavaScript
function onHtmsResponse(id, html) {
    document.querySelector(`script[data-htms="${id}"]`).remove();
    document.querySelector(`[data-htms="${id}"]`).outerHTML = html;
}
```

**No hydration. No client-side routing. No complex state management.** Just HTML that fills itself in.

## 😉 The "Trust Me Bro" Comparison Chart

|                         | HTMS       | Traditional SPA | SSR + Hydration |
|-------------------------|------------|-----------------|-----------------|
| **First Paint**         | 🟢 Instant | 🔴 Slow         | 🟢 Fast         |
| **SEO**                 | 🟢 Perfect | 🔴 Complex      | 🟢 Great        |
| **Progressive Loading** | 🟢 Native  | 🟢 Yes          | 🔴 No           |
| **Complexity**          | 🟢 Simple  | 🔴 High         | 🔴 Very High    |
| **JavaScript Required** | 🟢 4 lines | 🔴 Lots         | 🔴 Lots         |

## ⚠️ The Fine Print (AKA Reality Check)

**HTMS is experimental AF.** 🧪

This project started as "hold up, HTML streaming has been a thing since the late 90s, and nobody talks about it?! Time
to
experiment" and spiraled into a full-blown rabbit hole of Rust learning and web development philosophy.

### 🎯 What This Really Is:

- A **learning playground** where I'm leveling up my Rust skills
- An **experiment** in making web development more enjoyable
- A **proof of concept** that streaming HTML doesn't have to suck
- Definitely **NOT production ready** (yet?)

### 🎢 What to Expect:

- **~~Rapid~~ iteration** - things might change dramatically between versions or not at all
- **Breaking changes** - semantic versioning is more like... semantic suggestions
- **Rough edges** - some features are held together with digital duct tape
- **Fun surprises** - new features might appear overnight (or disappear)

### 🤷 The Honest Truth:

I'm having way too much fun building this to promise anything stable. Use it, break it, contribute to it, but maybe
don't bet your startup on it just yet.

**But hey,** if you're as curious about the future of HTML streaming as I am, welcome aboard this beautiful mess! 🚀

---

*Disclaimer: Side effects may include uncontrollable urges to rewrite your entire frontend.*

*Disclaimer 2: Readme written by human + AI. We're still debating who did the heavy lifting.* 🤖✍️
